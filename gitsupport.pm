#!/usr/bin/perl -w
package gitsupport;
use strict;

require Exporter;
our ($VERSION, @ISA, @EXPORT, @EXPORT_OK, %EXPORT_TAGS);
$VERSION = "1.0";
@ISA = qw(Exporter);
@EXPORT = qw(
&addentry &diffhash &addgitinfo &addgitlinks
);

our %gitinfo=();
our $debug=1;

sub addentry($$$)
{my($bugmap, $bugid,$commit)=@_;
	my $h=$bugmap->{$bugid}||{};
	my %h=%$h; # deep copy to allow diffhash to work
	$h{$commit}=1;
	$bugmap->{$bugid}=\%h;
}

# h1 is assumed to always contain more entries than h2
sub diffhash($$)
{ my($h1,$h2)=@_;
	my @a;
	foreach my $x (sort(keys(%$h1))) {
		next if($h2->{$x});
		push(@a,$x)
	}
	return \@a;
}

sub addgitinfo($$$)
{ my($commit,$branch,$sha)=@_;
	$gitinfo{$commit}={branch=>$branch, sha=>$sha};
}

use SOAP::Transport::HTTP;  # Need for Basic Authorization subroutine
use XMLRPC::Lite;           # From the SOAP::Lite Module
use JSON::XS;
our ($username,$password);
#our $apiserver="api.opensuse.org";
our $commitfile="~/src/kbuild/kernel-source.git/hooks/bugzilla.data";
our $privatecomment=0;
our $bugzillahandle;
our $coder = JSON::XS->new->ascii->pretty->allow_nonref->allow_blessed->convert_blessed;
eval(`/bin/cat $ENV{HOME}/.bugzillarc`);
our $gitserver="git.suse.com/cgit/kernel-source/commit/"

sub bugzillahandle()
{
	#$bugzillahandle=XMLRPC::Lite->proxy("https://apibugzilla.novell.com/tr_xmlrpc.cgi") if(!$bugzillahandle);
	$bugzillahandle=XMLRPC::Lite->proxy("https://apibugzilla.novell.com/xmlrpc.cgi") if(!$bugzillahandle);
	return $bugzillahandle;
}

sub SOAP::Transport::HTTP::Client::get_basic_credentials 
{ 
	return $username => $password;
}

sub die_on_fault 
{ my $soapresult = shift;
	if ($soapresult->fault)
	{
		die $soapresult->faultcode . ' ' . $soapresult->faultstring;
	}
}

sub getbug($)
{ my($bugid)=@_;
	my $proxy=bugzillahandle();
	$soapresult;
	eval {$soapresult = $proxy->call('Bug.comments', {ids=>[$bugid]});};
	$soapresult ||= {_content=>[0,1,2,3,"failed $@"]};
}
sub bugjson($)
{ my $soapresult=shift;
	my $bugjson=$coder->encode ($soapresult->{_content}->[4]);
}

sub filtercommit($@)
{ my($bugjson, @commit)=@_;
	my @commit2;
	# drop linked commits:
	foreach my $commit (@commit) {
		next if $bugjson=~m/id=\/$commit\b/;
		push(@commit2, $commit); # keep commit
	}
	return @commit2;
}

sub giturl(@)
{
	return join("",map {"https://$gitserver/cgit/kernel-source/committ/$_\n"} @_);
}

sub giturlplusinfo(@)
{
	return join("",map {
		my $commit=$_;
		my $info="";
		if(my $i=$gitinfo{$commit}) {$info=" $i->{branch} / $i->{bsc}"}
		giturl($commit.$info);
	 } @_);
}

sub addbugcomment($$;$)
{ my($bugid, $comment, $p)=@_;
	my $proxy=bugzillahandle;
	$p||=0;
	my $soapresult2 = $proxy->call('Bug.add_comment', {id => $bugid, comment => $comment, is_private=>$p, private=>$p, isprivate=>$p});
	die_on_fault($soapresult2);
}

sub addgitlinks($@)
{ my($bugid, @commit)=@_;
	return 2 unless $bugid=~s/^bnc#//; # ignore others for now
	eval { # catch die
		my @commit2=filtercommit(bugjson(getbug($bugid)), @commit);
		return unless @commit2;
		my $comment="This is an autogenerated message for GIT integration:\nThis bug ($bugid) was mentioned in\n".giturlplusinfo(@commit2)."\n";
		if(!$debug) {
			print "adding to https://bugzilla.suse.com/show_bug.cgi?id=$bugid\n$comment\n";
			addbugcomment($bugid, $comment, $privatecomment);
		} else {
			print "debug: would have added:\n$comment\n";
		}
	};
	return 1 unless $@; # all OK
	warn $@; # error
	return 0;
}

1;
